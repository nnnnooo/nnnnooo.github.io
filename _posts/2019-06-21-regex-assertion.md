---
layout: post
title:  "正则表达式零宽断言、贪婪与懒惰"
date:   2019-06-21
---

> [参考](https://blog.51cto.com/cnn237111/749047)

正则表达式的先行断言和后行断言一共有 4 种形式：
* (?=exp) 零宽正向先行断言 (zero-width positive lookahead assertion)
* (?!exp) 零宽负向先行断言 (zero-width negative lookahead assertion)
* (?<=exp) 零宽正向后行断言 (zero-width positive lookbehind assertion)
* (?<!exp) 零宽负向后行断言 (zero-width negative lookbehind assertion)

### 零宽断言

如同 ^ 代表开头，$ 代表结尾，\b 代表单词边界一样，先行断言和后行断言也有类似的作用，它们只匹配某些**位置**，在匹配过程中，不占用字符，所以被称为 “零宽”。

### (?=exp) 正向先行断言
> 匹配后面跟的不是exp的位置
代表字符串中的一个位置，**紧接该位置之后**的字符序列**能够匹配** exp。
例如对”a regular expression” 这个字符串，要想匹配 **re**gular 中的 re，但不能匹配 expression 中的 re，可以用”re (?=gular)”，该表达式限定了 re 右边的位置，这个位置之后是 gular，但并不消耗 gular 这些字符，将表达式改为”re (?=gular).”，将会匹配 reg，元字符。匹配了 g，括号这一砣匹配了 e 和 g 之间的位置。

### (?!exp) 负向先行断言
> 匹配exp后面的位置代表字符串中的一个位置，**紧接该位置之后**的字符序列**不能匹配** exp。
例如对”regex represents regular expression” 这个字符串，要想匹配除 **re**gex 和 **re**gular 之外的 re，可以用”re (?!g)”，该表达式限定了 re 右边的位置，这个位置后面不是字符 g。负向和正向的区别，就在于该位置之后的字符能否匹配括号中的表达式。

### (?<=exp) 正向后行断言
> 匹配exp前面的s位置
代表字符串中的一个位置，**紧接该位置之前**的字符序列**能够匹配** exp。
例如对”regex represents regular expression” 这个字符串，有 4 个单词，要想匹配单词内部的 re，但不匹配单词开头的 re，可以用”(?<=\w) re”，单词内部的 re，在 re 前面应该是一个单词字符。之所以叫后行断言，是因为正则表达式引擎在匹配字符串和表达式时，是从前向后逐个扫描字符串中的字符，并判断是否与表达式符合，当在表达式中遇到该断言时，正则表达式引擎需要往字符串前端检测已扫描过的字符，相对于扫描方向是向后的。

### (?<!exp) 负向后行断言
匹配前面不是exp的位置
代表字符串中的一个位置，**紧接该位置之前**的字符序列**不能匹配** exp。
例如对”regex represents regular expression” 这个字符串，要想匹配单词开头的 re，可以用”(?<!\w) re”。单词开头的 re，在本例中，也就是指不在单词内部的 re，即 re 前面不是单词字符。当然也可以用”\bre” 来匹配。

**贪婪**：匹配尽可能多的字符。
**懒惰**：匹配尽可能少的字符。限定符后面加上一个问号'?'

懒惰限定符
| 代码/语法 | 说明 |
| `*?` | 重复任意次，但尽可能少重复 |
| `+?` | 重复1次或更多次，但尽可能少重复 |
| `??` | 重复0次或1次，但尽可能少重复 |
| `{n,m}?` | 重复n到m次，但尽可能少重复 |
| `{n,}?` | 重复n次以上，但尽可能少重复 |

